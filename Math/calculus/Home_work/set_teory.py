"""Repetitio est matter studiorum."""

# #### 27/05/2024. Теория множеств.

# <p>N - множество всех натуральных чисел {1,2,3,4,...} (целые числа от единицы до бесконечности )
# <p>Z - множество целых чисел {...-2, -1, 0, 1, 2,...} (целые числа от минус бесконечности до плюс бесконечности)
# <p>N/Z - {0, 1, 2, 3, ...}
# <p>Q - множество рациональных чисел {..., -3/4, 0, 1/2 ...} (целые числа и дроби от минус бесконечности <p>до плюс бесконечности)
# <p>I - множество иррациональных чисел {sqrt5, (1+sqrt3)/5, l, число Пи}
# <p>R - множество действительных вещественных чисел {-2, число Пи, 0.5, sqrt5, 0}
# <p>C - множество комплексных чисел. В него включена С - мнимая единица.

# <p>Знаки для работы с множествами.
# <p>Ø	пустой набор, пустое множество или множество, не имеющее составных элементов
# Ø = {}	A = Ø
# <p>a ∈ A	элемент, принадлежит	установить членство
# A = {3,9,14}, 3 ∈ A
# <p>x ∉ A	не элемент	нет установленного членства
# A = {3,9,14}, 1 ∉ A
# <p>A ⊂ B	ВКЛЮЧЕНО правильное подмножество / строгое подмножество	A является подмножеством B, но A неравно B.
# {9,14} ⊂ {9,14,28}
# <p>A ⊃ B	ВКЛЮЧАЕТ правильный суперсет / строгий суперсет	A является надмножеством B, но B не равно А.
# {9,14,28} ⊃ {9,14}
# <p>A ⊆ B НЕ СТРОГОЕ ВКЛЮЧЕНИЕ (включено или совпадает)	подмножество	A является подмножеством B. множество A включено в набор B.
# {9,14,28} ⊆ {9,14,28}
# <p>A ⊇ B	НЕ СТРОГОЕ ВКЛЮЧЕНИЕ (включено или совпадает) суперсет	A является надмножеством B. множество A включает множество B
# {9,14,28} ⊇ {9,14,28}
# <p>A ∆ B	симметричная разница (антипересечение)	объекты, принадлежащие A или B, но не их пересечение
# A = {3,9,14},
# B = {1,2,3},
# A ∆ B = {1,2,9,14}
# <p>A⋂B	пересечение	объекты, принадлежащие множеству A и множеству B
# A ⋂ B = {9,14}
# <p>A⋃B	союз	объекты, принадлежащие множеству A или множеству B
# A ⋃ B = {3,7,9,14,28}
#

# Круги Эйлера - это разновидность диаграмм, графический инструмент для визуализации связей между различными множествами или группами данных.

# <p>Если каждому натуральному числу n поставлено в соответсвие определенное действительное число x_n, то говорят, что задана числовая последовательность x_1, x_2, x_3, ..., x_n.
# <p>Числа х_1, х_2 - это элементы или члены последовательности.
# <p>Символ х_n - общий элемент / общий член последовательности.
# <p>n - номер этого элемента.
# <p>Сокращенно последовтаельность обозначается {x_n}.
# <p>Последовательность считается заданной, если указан способ получения любог ее элемента.
# <p>Последовательность может быть задана ФОРМУЛОЙ ЕЕ ОБЩЕГО ЧЛЕНА. Эта формула позволяет вычислить любой член последовательности по номеру n.
# <p>Например, равенство x_n = 1/n задает последовательность x_1 = 1/1 = 1, x_2 = 1/2, x_3 = 1/3 (1, 1/2, 1/3).
# <p>Для задания последовательности также используется РЕККУРЕНТНЫЙ СПОСОБ. Когда первый член последовательности х_1 и правило определения n-го члена, например по формуле n-1. Т.о. каждый следующий член находится через предидущий.
# <p>ПРИМЕРЫ таких последовательностей
# <p>1) арифметическая и геометрическая последовательности, числа Фибоначчи.
# <p>2) x_n = f_(n-1) при таком способе задания последовательноти для определения n-го члена надо сначала посчитать все (n-1) предидущих членов.
# <p>3)

# #### 28/05/2024. Пределы.

#
# 1. Бесконечно малые и бесконечно большие последовательности
# 2. последовательность {a_n} является бесконечно малой, если для любого положительного числа эпсилон существует номер N  такой, что при n > N   выполняется неравенство {a-n} < эпсилон
# 3. посдедовательность {x_n} явялется бескорнечно большой, если для любого положительного числа A существует номер N  такой, что при n > N  выполняется неравенство {x_n > A}
# 4. Символ ЭПСИЛОН  означает малое положительное число близкое к нулю и используемое для определния пределов.
# 5. Теорема о связи малых и бесконечно больших последовательностей.
# 6.

# #### 31/05/2024.

#
# 1. Предел числовой последовательности
# 2. lim x_n = a <+> Ɐ

# #### 21.06.2024 Комбинаторика. Урок 1. Формула количества перестановок в Питоне без повторений.

# Основные термины:
#
# <p>**Класс.**<br>
# В классах описываются свойства объектов и действия объектов или совершаемые над ними действия.<br>
# Свойства объектов называются **атрибутами**. По сути атрибуты — переменные, в значениях которых хранятся свойства объекта.
# <p>Действия объектов называются **методами**. Методы очень похожи на функции, в них можно передавать аргументы и возвращать значения с помощью оператора return, но вызываются методы после указания конкретного объекта.<br>
# Методы в Python — это функции, связанные с объектами. Они вызываются на конкретных объектах и могут изменять их состояние. Методы определяются внутри классов и могут обращаться к данным объекта через **ключевое слово self**. Методы могут выполнять операции над данными объекта.
# <p>Для чего нужны классы в питоне?<br>
# Классы помогают кратко и понятно описывать объекты и их поведение независимо от основного кода программы. Затем в основном коде можно просто создавать объекты на основе классов и работать с ними, уже не описывая их свойств и поведения.<br>
# Имена **класса** всегда пишутся **зеленым** цветом
#
# <p>**Объект** -   чтобы создать объект класса необходимо воспользоваться следующим синтаксисом: имя_объекта = имя_класса ().
# <p>Итерируемый объект
# <p>**Сигнатура объекта**. Заглянем в документацию, первые две строки, описывающие входные параметры функции - это есть её сигнатура.
# Знак вопроса (?) - вызывает сигнатуру обьекта.
#
# <p>**Функция.**
# <p>Функции в Python — это блок кода, который выполняет определённую задачу при вызове. Они могут быть определены с помощью **ключевого слова def**, принимать аргументы и возвращать значения с помощью **return**.
# <p>Функции могут вызываться независимо от какого-либо объекта.
# <p>**Функции** всегда пишутся **желтым** цветом.

# Язык программирования Python является объектно-ориентированным. Это означает, что каждая сущность (переменная, функция и т. д.) в этом языке является объектом определённого класса.
#
# Основные понятия объектно-ориентированного программирования
# Объектно-ориентированное программирование (ООП) является методологией разработки программного обеспечения, в основе которой лежит понятие класса и объекта, при этом сама программа создается как некоторая совокупность объектов, которые взаимодействую друг с другом и с внешним миром. Каждый объект является экземпляром некоторого класса. Классы образуют иерархии.
#
# Выделяют три основных “столпа” ООП- это инкапсуляция, наследование и полиморфизм.
#
# Инкапсуляция
# Под инкапсуляцией понимается сокрытие деталей реализации, данных и т.п. от внешней стороны. Например, можно определить класс “холодильник”, который будет содержать следующие данные: производитель, объем, количество камер хранения, потребляемая мощность и т.п., и методы: открыть/закрыть холодильник, включить/выключить, но при этом реализация того, как происходит непосредственно включение и выключение пользователю вашего класса не доступна, что позволяет ее менять без опасения, что это может отразиться на использующей класс «холодильник» программе. При этом класс становится новым типом данных в рамках разрабатываемой программы. Можно создавать переменные этого нового типа, такие переменные называются объекты.
#
# Наследование
# Под наследованием понимается возможность создания нового класса на базе существующего. Наследование предполагает наличие отношения “является” между классом наследником и классом родителем. При этом класс потомок будет содержать те же атрибуты и методы, что и базовый класс, но при этом его можно (и нужно) расширять через добавление новых методов и атрибутов.
#
# Примером базового класса, демонстрирующего наследование, можно определить класс “автомобиль”, имеющий атрибуты: масса, мощность двигателя, объем топливного бака и методы: завести и заглушить. У такого класса может быть потомок – “грузовой автомобиль”, он будет содержать те же атрибуты и методы, что и класс “автомобиль”, и дополнительные свойства: количество осей, мощность компрессора и т.п..
#
# Полиморфизм
# Полиморфизм позволяет одинаково обращаться с объектами, имеющими однотипный интерфейс, независимо от внутренней реализации объекта. Например, с объектом класса “грузовой автомобиль” можно производить те же операции, что и с объектом класса “автомобиль”, т.к. первый является наследником второго, при этом обратное утверждение неверно (во всяком случае не всегда). Другими словами полиморфизм предполагает разную реализацию методов с одинаковыми именами. Это очень полезно при наследовании, когда в классе наследнике можно переопределить методы класса родителя.

# Количество перестановок списка - это факториал длины списка, деленный на произведение факториалов кратности каждого элемента.

# <p>Мы из библиотеки itertools установили один класс permutation.<b>
# permutation - это  класс, встроенная инструкция для создания обьектов, она содержит формулу количества перестановок без повторений.<b>
# from itertools import permutations
#
# Приступили к решению задачи: даны три фрукта, яблоко, груша и банан. Вопрос: сколькими способами их можно переставить?
#
# perm = permutations(["яблоко", "груша", "банан"])
#
# Задали переменную perm присвоив ей значение обьекта.
# Объект создали задав аргументы классу permutations в виде списка в квадратных скобках: ["яблоко", "груша", "банан"].
# Объект класса создается помещением его в круглые скобки.
#
# list(perm)
#
# Обратите внимание: функции библиотеки itertools возвращают не список, а итератор. Он не хранит все значения сразу, а позволяет один раз последовательно пройти по ним в цикле.
# Для сохранения всех значений итератора его можно преобразовать в список с помощью функции list().
#
# [('яблоко', 'груша', 'банан'),
#  ('яблоко', 'банан', 'груша'),
#  ('груша', 'яблоко', 'банан'),
#  ('груша', 'банан', 'яблоко'),
#  ('банан', 'яблоко', 'груша'),
#  ('банан', 'груша', 'яблоко')]
#
#  Вот такой результат мы получили.
#
# count_perm = len(list(perm))
#
# Дальше мы использовали функцию len для подсчета количества возможных итераций.
#
# count_perm
#
# И вывели его на экран
#
# 6

# #### 25.06.2024 Учимся работать с Markdown. Погружаемся в понимание Питона.

# json файлы.
# Понятие
# Назначение
#
